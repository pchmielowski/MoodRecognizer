#pragma once;
#include <vector>
#include <boost/math/distributions/normal.hpp>
#include "opencv/cv.h"

using namespace boost::math;
using namespace cv;
class Ubm
{
public:
	int numGaussComponents_;
	cv::Mat weights_;
	cv::Mat means_;
	std::vector<std::vector<boost::math::normal_distribution<>>> distribution_;
	double logLikelihood(const cv::Mat& x, int gaussComponentIdx) const {
		double likelihood = 1;
		int numCoeff = x.rows;
		for (int coefIdx = 0; coefIdx < numCoeff; coefIdx++) {
			// czy to nie powinien byæ log likelihood?
			likelihood *= pdf(distribution_[gaussComponentIdx][coefIdx], 
				x.at<double>(coefIdx));
		}
		return log(likelihood);
	}
	void createNormalDistribution(int numDimensions, vector<Mat> covs)
	{
		assert(means_.rows == numDimensions);
		assert(means_.cols == numGaussComponents_);
		assert(covs.size() == numGaussComponents_);
		assert(covs[0].rows == numDimensions);
		assert(covs[0].cols == numDimensions);
		assert(covs[0].at<double>(0, 1) == covs[0].at<double>(1, 0) == 0);
		//vector<vector<normal_distribution<>>> norm_distr;
		distribution_.resize(numGaussComponents_, vector<normal_distribution<>>(numDimensions, NULL));
		for (int dimensionIdx = 0; dimensionIdx < numDimensions; dimensionIdx++) {
			for (int componentIdx = 0; componentIdx < numGaussComponents_; componentIdx++) {
				distribution_[componentIdx][dimensionIdx] = normal_distribution<>(means_.at<double>(dimensionIdx, componentIdx),
					sqrt(covs[componentIdx].at<double>(dimensionIdx, dimensionIdx)));
			}
		}
		//return norm_distr;
	}
};